{"ast":null,"code":"import { isJest } from \"./PlatformChecker\";\nimport { runOnUI } from \"./threads\";\nimport { isSharedValue } from \"./utils\";\nvar IS_JEST = isJest();\nexport var createMapperRegistry = function () {\n  var _f = function _f() {\n    var mappers = new Map();\n    var sortedMappers = [];\n    var runRequested = false;\n    var processingMappers = false;\n    function updateMappersOrder() {\n      var pre = new Map();\n      mappers.forEach(function (mapper) {\n        if (mapper.outputs) {\n          for (var output of mapper.outputs) {\n            var preMappers = pre.get(output);\n            if (preMappers === undefined) {\n              pre.set(output, [mapper]);\n            } else {\n              preMappers.push(mapper);\n            }\n          }\n        }\n      });\n      var visited = new Set();\n      var newOrder = [];\n      function dfs(mapper) {\n        visited.add(mapper);\n        for (var input of mapper.inputs) {\n          var preMappers = pre.get(input);\n          if (preMappers) {\n            for (var preMapper of preMappers) {\n              if (!visited.has(preMapper)) {\n                dfs(preMapper);\n              }\n            }\n          }\n        }\n        newOrder.push(mapper);\n      }\n      mappers.forEach(function (mapper) {\n        if (!visited.has(mapper)) {\n          dfs(mapper);\n        }\n      });\n      sortedMappers = newOrder;\n    }\n    function mapperRun() {\n      processingMappers = true;\n      runRequested = false;\n      if (mappers.size !== sortedMappers.length) {\n        updateMappersOrder();\n      }\n      for (var mapper of sortedMappers) {\n        if (mapper.dirty) {\n          mapper.dirty = false;\n          mapper.worklet();\n        }\n      }\n      processingMappers = false;\n    }\n    function maybeRequestUpdates() {\n      if (IS_JEST) {\n        mapperRun();\n      } else if (!runRequested) {\n        if (processingMappers) {\n          requestAnimationFrame(mapperRun);\n        } else {\n          queueMicrotask(mapperRun);\n        }\n        runRequested = true;\n      }\n    }\n    function extractInputs(inputs, resultArray) {\n      if (Array.isArray(inputs)) {\n        for (var input of inputs) {\n          input && extractInputs(input, resultArray);\n        }\n      } else if (isSharedValue(inputs)) {\n        resultArray.push(inputs);\n      } else if (Object.getPrototypeOf(inputs) === Object.prototype) {\n        for (var element of Object.values(inputs)) {\n          element && extractInputs(element, resultArray);\n        }\n      }\n      return resultArray;\n    }\n    return {\n      start: function start(mapperID, worklet, inputs, outputs) {\n        var mapper = {\n          id: mapperID,\n          dirty: true,\n          worklet: worklet,\n          inputs: extractInputs(inputs, []),\n          outputs: outputs\n        };\n        mappers.set(mapper.id, mapper);\n        sortedMappers = [];\n        for (var sv of mapper.inputs) {\n          sv.addListener(mapper.id, function () {\n            mapper.dirty = true;\n            maybeRequestUpdates();\n          });\n        }\n        maybeRequestUpdates();\n      },\n      stop: function stop(mapperID) {\n        var mapper = mappers.get(mapperID);\n        if (mapper) {\n          mappers.delete(mapper.id);\n          sortedMappers = [];\n          for (var sv of mapper.inputs) {\n            sv.removeListener(mapper.id);\n          }\n        }\n      }\n    };\n  };\n  _f._closure = {\n    IS_JEST: IS_JEST,\n    queueMicrotask: queueMicrotask,\n    isSharedValue: isSharedValue\n  };\n  _f.asString = \"function createMapperRegistry(){const{IS_JEST,queueMicrotask,isSharedValue}=jsThis._closure;{const mappers=new Map();let sortedMappers=[];let runRequested=false;let processingMappers=false;function updateMappersOrder(){const pre=new Map();mappers.forEach(function(mapper){if(mapper.outputs){for(const output of mapper.outputs){const preMappers=pre.get(output);if(preMappers===undefined){pre.set(output,[mapper]);}else{preMappers.push(mapper);}}}});const visited=new Set();const newOrder=[];function dfs(mapper){visited.add(mapper);for(const input of mapper.inputs){const preMappers=pre.get(input);if(preMappers){for(const preMapper of preMappers){if(!visited.has(preMapper)){dfs(preMapper);}}}}newOrder.push(mapper);}mappers.forEach(function(mapper){if(!visited.has(mapper)){dfs(mapper);}});sortedMappers=newOrder;}function mapperRun(){processingMappers=true;runRequested=false;if(mappers.size!==sortedMappers.length){updateMappersOrder();}for(const mapper of sortedMappers){if(mapper.dirty){mapper.dirty=false;mapper.worklet();}}processingMappers=false;}function maybeRequestUpdates(){if(IS_JEST){mapperRun();}else if(!runRequested){if(processingMappers){requestAnimationFrame(mapperRun);}else{queueMicrotask(mapperRun);}runRequested=true;}}function extractInputs(inputs,resultArray){if(Array.isArray(inputs)){for(const input of inputs){input&&extractInputs(input,resultArray);}}else if(isSharedValue(inputs)){resultArray.push(inputs);}else if(Object.getPrototypeOf(inputs)===Object.prototype){for(const element of Object.values(inputs)){element&&extractInputs(element,resultArray);}}return resultArray;}return{start:function(mapperID,worklet,inputs,outputs){const mapper={id:mapperID,dirty:true,worklet:worklet,inputs:extractInputs(inputs,[]),outputs:outputs};mappers.set(mapper.id,mapper);sortedMappers=[];for(const sv of mapper.inputs){sv.addListener(mapper.id,function(){mapper.dirty=true;maybeRequestUpdates();});}maybeRequestUpdates();},stop:function(mapperID){const mapper=mappers.get(mapperID);if(mapper){mappers.delete(mapper.id);sortedMappers=[];for(const sv of mapper.inputs){sv.removeListener(mapper.id);}}}};}}\";\n  _f.__workletHash = 7442040218940;\n  _f.__location = \"/cs/home/sz78/Documents/P4_expo/node_modules/react-native-reanimated/lib/module/reanimated2/mappers.js (5:7)\";\n  return _f;\n}();\nvar MAPPER_ID = 9999;\nexport function startMapper(worklet) {\n  var inputs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var outputs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var mapperID = MAPPER_ID += 1;\n  runOnUI(function () {\n    var _f = function _f() {\n      var mapperRegistry = global.__mapperRegistry;\n      if (mapperRegistry === undefined) {\n        mapperRegistry = global.__mapperRegistry = createMapperRegistry();\n      }\n      mapperRegistry.start(mapperID, worklet, inputs, outputs);\n    };\n    _f._closure = {\n      createMapperRegistry: createMapperRegistry,\n      mapperID: mapperID,\n      worklet: worklet,\n      inputs: inputs,\n      outputs: outputs\n    };\n    _f.asString = \"function _f(){const{createMapperRegistry,mapperID,worklet,inputs,outputs}=jsThis._closure;{let mapperRegistry=global.__mapperRegistry;if(mapperRegistry===undefined){mapperRegistry=global.__mapperRegistry=createMapperRegistry();}mapperRegistry.start(mapperID,worklet,inputs,outputs);}}\";\n    _f.__workletHash = 15232186229521;\n    _f.__location = \"/cs/home/sz78/Documents/P4_expo/node_modules/react-native-reanimated/lib/module/reanimated2/mappers.js (165:10)\";\n    return _f;\n  }())();\n  return mapperID;\n}\nexport function stopMapper(mapperID) {\n  runOnUI(function () {\n    var _f = function _f() {\n      var mapperRegistry = global.__mapperRegistry;\n      mapperRegistry === null || mapperRegistry === void 0 ? void 0 : mapperRegistry.stop(mapperID);\n    };\n    _f._closure = {\n      mapperID: mapperID\n    };\n    _f.asString = \"function _f(){const{mapperID}=jsThis._closure;{const mapperRegistry=global.__mapperRegistry;mapperRegistry===null||mapperRegistry===void 0?void 0:mapperRegistry.stop(mapperID);}}\";\n    _f.__workletHash = 13142579052317;\n    _f.__location = \"/cs/home/sz78/Documents/P4_expo/node_modules/react-native-reanimated/lib/module/reanimated2/mappers.js (177:10)\";\n    return _f;\n  }())();\n}","map":{"version":3,"names":["isJest","runOnUI","isSharedValue","IS_JEST","createMapperRegistry","_f","mappers","Map","sortedMappers","runRequested","processingMappers","updateMappersOrder","pre","forEach","mapper","outputs","output","preMappers","get","undefined","set","push","visited","Set","newOrder","dfs","add","input","inputs","preMapper","has","mapperRun","size","length","dirty","worklet","maybeRequestUpdates","requestAnimationFrame","queueMicrotask","extractInputs","resultArray","Array","isArray","Object","getPrototypeOf","prototype","element","values","start","mapperID","id","sv","addListener","stop","delete","removeListener","_closure","asString","__workletHash","__location","MAPPER_ID","startMapper","arguments","mapperRegistry","global","__mapperRegistry","stopMapper"],"sources":["/cs/home/sz78/Documents/P4_expo/node_modules/react-native-reanimated/lib/module/reanimated2/mappers.ts"],"sourcesContent":["import { SharedValue } from './commonTypes';\nimport { isJest } from './PlatformChecker';\nimport { runOnUI } from './threads';\nimport { isSharedValue } from './utils';\n\nconst IS_JEST = isJest();\n\nexport type Mapper = {\n  id: number;\n  dirty: boolean;\n  worklet: () => void;\n  inputs: SharedValue<any>[];\n  outputs?: SharedValue<any>[];\n};\n\nexport function createMapperRegistry() {\n  'worklet';\n  const mappers = new Map();\n  let sortedMappers: Mapper[] = [];\n\n  let runRequested = false;\n  let processingMappers = false;\n\n  function updateMappersOrder() {\n    // sort mappers topologically\n    // the algorithm here takes adventage of a fact that the topological order\n    // of a transposed graph is a reverse topological order of the original graph\n    // The graph in our case consists of mappers and an edge between two mappers\n    // A and B exists if there is a shared value that's on A's output lists and on\n    // B's input list.\n    //\n    // We don't need however to calculate that graph as it is easier to work with\n    // the transposed version of it that can be calculated ad-hoc. For the transposed\n    // version to be traversed we use \"pre\" map that maps share value to mappers that\n    // output that shared value. Then we can infer all the outgoing edges for a given\n    // mapper simply by scanning it's input list and checking if any of the shared values\n    // from that list exists in the \"pre\" map. If they do, then we have an edge between\n    // that mapper and the mappers from the \"pre\" list for the given shared value.\n    //\n    // For topological sorting we use a dfs-based approach that requires the graph to\n    // be traversed in dfs order and each node after being processed lands at the\n    // beginning of the topological order list. Since we traverse a transposed graph,\n    // instead of reversing that order we can use a normal array and push processed\n    // mappers to the end. There is no need to reverse that array after we are done.\n    const pre = new Map(); // map from sv -> mapper that outputs that sv\n    mappers.forEach((mapper) => {\n      if (mapper.outputs) {\n        for (const output of mapper.outputs) {\n          const preMappers = pre.get(output);\n          if (preMappers === undefined) {\n            pre.set(output, [mapper]);\n          } else {\n            preMappers.push(mapper);\n          }\n        }\n      }\n    });\n    const visited = new Set();\n    const newOrder: Mapper[] = [];\n    function dfs(mapper: Mapper) {\n      visited.add(mapper);\n      for (const input of mapper.inputs) {\n        const preMappers = pre.get(input);\n        if (preMappers) {\n          for (const preMapper of preMappers) {\n            if (!visited.has(preMapper)) {\n              dfs(preMapper);\n            }\n          }\n        }\n      }\n      newOrder.push(mapper);\n    }\n    mappers.forEach((mapper) => {\n      if (!visited.has(mapper)) {\n        dfs(mapper);\n      }\n    });\n    sortedMappers = newOrder;\n  }\n\n  function mapperRun() {\n    processingMappers = true;\n    runRequested = false;\n    if (mappers.size !== sortedMappers.length) {\n      updateMappersOrder();\n    }\n    for (const mapper of sortedMappers) {\n      if (mapper.dirty) {\n        mapper.dirty = false;\n        mapper.worklet();\n      }\n    }\n    processingMappers = false;\n  }\n\n  function maybeRequestUpdates() {\n    if (IS_JEST) {\n      // On Jest environment we avoid using queueMicrotask as that'd require test\n      // to advance the clock manually. This on other hand would require tests\n      // to know how many times mappers need to run. As we don't want tests to\n      // make any assumptions on that number it is easier to execute mappers\n      // immediately for testing purposes and only expect test to advance timers\n      // if they want to make any assertions on the effects of animations being run.\n      mapperRun();\n    } else if (!runRequested) {\n      if (processingMappers) {\n        // In general, we should avoid having mappers trigger updates as this may\n        // result in unpredictable behavior. Specifically, the updated value can\n        // be read by mappers that run later in the same frame but previous mappers\n        // would access the old value. Updating mappers during the mapper-run phase\n        // breaks the order in which we should execute the mappers. However, doing\n        // that is still a possibility and there are some instances where people use\n        // the API in that way, hence we need to prevent mapper-run phase falling into\n        // an infinite loop. We do that by detecting when mapper-run is requested while\n        // we are already in mapper-run phase, and in that case we use `requestAnimationFrame`\n        // instead of `queueMicrotask` which will schedule mapper run for the next\n        // frame instead of queuing another set of updates in the same frame.\n        requestAnimationFrame(mapperRun);\n      } else {\n        queueMicrotask(mapperRun);\n      }\n      runRequested = true;\n    }\n  }\n\n  function extractInputs(\n    inputs: any,\n    resultArray: SharedValue<any>[]\n  ): SharedValue<any>[] {\n    if (Array.isArray(inputs)) {\n      for (const input of inputs) {\n        input && extractInputs(input, resultArray);\n      }\n    } else if (isSharedValue(inputs)) {\n      resultArray.push(inputs);\n    } else if (Object.getPrototypeOf(inputs) === Object.prototype) {\n      // we only extract inputs recursively from \"plain\" objects here, if object\n      // is of a derivative class (e.g. HostObject on web, or Map) we don't scan\n      // it recursively\n      for (const element of Object.values(inputs)) {\n        element && extractInputs(element, resultArray);\n      }\n    }\n    return resultArray;\n  }\n\n  return {\n    start: (\n      mapperID: number,\n      worklet: () => void,\n      inputs: SharedValue<any>[],\n      outputs?: SharedValue<any>[]\n    ) => {\n      const mapper = {\n        id: mapperID,\n        dirty: true,\n        worklet,\n        inputs: extractInputs(inputs, []),\n        outputs,\n      };\n      mappers.set(mapper.id, mapper);\n      sortedMappers = [];\n      for (const sv of mapper.inputs) {\n        sv.addListener(mapper.id, () => {\n          mapper.dirty = true;\n          maybeRequestUpdates();\n        });\n      }\n      maybeRequestUpdates();\n    },\n    stop: (mapperID: number) => {\n      const mapper = mappers.get(mapperID);\n      if (mapper) {\n        mappers.delete(mapper.id);\n        sortedMappers = [];\n        for (const sv of mapper.inputs) {\n          sv.removeListener(mapper.id);\n        }\n      }\n    },\n  };\n}\n\nlet MAPPER_ID = 9999;\n\nexport function startMapper(\n  worklet: () => void,\n  inputs: any[] = [],\n  outputs: any[] = []\n): number {\n  const mapperID = (MAPPER_ID += 1);\n\n  runOnUI(() => {\n    'worklet';\n    let mapperRegistry = global.__mapperRegistry;\n    if (mapperRegistry === undefined) {\n      mapperRegistry = global.__mapperRegistry = createMapperRegistry();\n    }\n    mapperRegistry.start(mapperID, worklet, inputs, outputs);\n  })();\n\n  return mapperID;\n}\n\nexport function stopMapper(mapperID: number): void {\n  runOnUI(() => {\n    'worklet';\n    const mapperRegistry = global.__mapperRegistry;\n    mapperRegistry?.stop(mapperID);\n  })();\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}